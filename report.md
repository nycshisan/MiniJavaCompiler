# 编译Project报告

###### 陈一川 14307110157@fudan.edu.cn

## 工具选择

没有使用第三方的词法\语法分析工具，这是因为我认为工业化的词法\语法分析工具（例如ANTLR）功能已经非常完善，凭我的能力无法再对其做改进。而我认为如果自己将工具链实现一遍，虽然效果相差许多，但能够学到更多的东西。其次，我去年时对编译原理比较感兴趣，曾经想自己实现一个编译器前端，但是半途而废了，这次趁此机会将它完成。（这也是git log中有去年的记录的原因）

我使用了正则表达式和组合子作为词法分析和语法分析的方式。具体见下。


## 词法分析

对应的主要文件为`src/Tokenizer/Tokenizer.swift`

我使用正则表达式作为从输入文本中不断获取Token的方式。原因有三，第一，正则表达式以足够表达MiniJava的简单词法，例如，MiniJava并没有C语言式的嵌套多行注释(`/* ... */`)这一正则表达式无法表达的词法规则；第二，贪婪的正则表达式自带最长匹配这一消除词法二义性的规则；第三，许多语言都自带一个正则表达式的执行器，Swift也不例外，使得使用正则表达式进行词法分析是简单易行的。

消除词法二义性的另一规则，规则优先，要求合适地设置正则表达式的匹配顺序。在本例中，我设置正则表达式的匹配顺序为(1)空白符与注释(2)运算符与定界符(3)特别的保留字(4)标识符(5)整数字面量。

所谓特别的保留字，实际上指的就是`System.out.println`，在实际语言中，他应该被识别为一个对象属性表达式。我在MiniJava中为了简单起见，直接将其用于打印语句的关键字，为了能在语法分析阶段直接使用`System.out.println`而非[`System`, `.`, ...]进行分析，需要在词法分析阶段增加特殊的规则，事后发现反而使得Tokenizer更加复杂了。

识别为标识符的Token会被检查，如果是保留字，Token类别就会被修改为保留字以供语法分析阶段使用。

我将空白符和注释也视为Token（这类Token在匹配完成后会被舍弃，不会进入语法分析阶段），因此可以不断地从输入文本的头部得到正则表达式的最大贪婪匹配。使用一系列正则表达式依次对输入进行匹配，每当有一个正则表达式的匹配长度大于0，就截取这一子串，包装为Token，加入结果队列，并将这一子串从输入本文中删去，然后重复上述过程。当输入文本耗尽时，词法分析阶段完成，输入文本被分割为Tokens数组。

**错误处理与恢复。**

在词法处理阶段，我只是简单地处理了字符集的错误。当遇到MiniJava不允许含有的字符时（例如或运算符|），报告错误，删去这一字符并回退到上一次词法分析成功的地方继续进行分析，并在分析完成后退出。

![](imgs/img1.png)

图为使用错误文本进行分析的输出。Tokenizer找出了全部的非法字符。

## 语法分析

对应的主要文件为`src/Parser/*.swift`

我使用组合子（Combinators）作为语法分析的工具，简单地来说，就是首先定义最简单的几类Parser，然后定义几种将其复合起来的操作，通过这些操作，定义能够分析复杂的语法规则的Parser，最后得到一个能够分析整个语法系统的Parser。

我起初在查阅资料时发现了这样一种实现编译器前端的解决模式，因为它与课本所讲的编译原理并不相同，我觉得用一种与课本不同（虽然本质原理相同）的方式实现编译器前端是很有趣的。项目完成后，现在我认为，组合子编程模型并不适合作为编译系统的前端的解决方案，因为（在最坏条件下）它需要前向查看到输入末尾才能确定第一个Token的意思，虽然在成功编译的情况下，这种最坏条件几乎不会发生，但是在错误处理和恢复时，为了确定错误类型，这种最坏情况就常常出现。尽管如此，我仍然认为这种实现是很有趣的，因此还是将它作为我的课程项目。

最简单的Parser只有两种，一种识别单个Token的文本，一种识别单个Token的类型（保留字、运算符、整数字面量、标识符等等）。它们接受Tokens数组当前正在被分析的位置的下标作为参数，在该下标指向的位置上进行分析，如果满足条件，则将该Token包装为ASTNode返回，并将该下标加一。

复合操作则有许多种，它们被称为组合子，因为它们将较简单的Parser组合起来产生新的较复杂的Parser。下面依次介绍我使用的组合子：

0. 和组合子  
和组合子是使用最多的组合子，它接收两个Parser，输出一个新的Parser。这个Parser在执行分析时会依次调用输入的两个Parser，当二者均成功返回时，则将二者的返回结果组织成AST的子结点，并将父节点返回；否则返回失败。  
和组合子用于分析依次的输入。例如，对于两个Parser，分别能够分析"1"和"+"，那么用和组合子产生的复合Parser就能够分析"1+"。  
特别的，对于输入的Parser，如果它是由和组合子产生的，则新的Parser会将它的结果展平后再进行组织，这是为了方便语义动作的编写。例如，"1+1"会被分析为[1, +, 1]而非[[1, +], 1]。

0. 或组合子  
或组合字同样将两个Parser组合为一个Parser。这个Parser会返回二者中分析成功的Parser的分析结果，只有当二者均失败时才返回失败，其效果和输入的优先级就像或运算符一样。  
或组合字用于分析并列的输入。例如对于分别能够分析"1"和"2"的两个Parser，其产生的新Parser可以分析"1"或者"2"。

0. 可选组合子  
可选组合子只接受一个Parser的输入，它修改这个Parser的行为，使得其失败时不返回失败，而是返回一个空的AST结点。  
可选组合子用于分析可选的语法现象，例如类是否有写明继承，或者if语句是否有else块（虽然在MiniJava中强制所有if语句带有else块）。

0. 重复组合子  
重复组合子也只接受一个Parser的输入，它产生新的Parser，该Parser可以贪婪地不断重复输入Parser的行为，直到分析失败为止。它将得到的结果组织成AST的子结点，并将父节点返回。  
重复组合子用于分析不定次出现的语法现象。例如对于能够分析"1"的Parser，经过重复组合子组合之后，就能将"111"分析为[1, 1, 1]。实际中，它被用来分析语句块中的多个语句等现象。

0. 间隔重复组合子  
间隔重复组合子分析带有间隔的重复语法现象，例如函数参数中，每个参数之间有逗号的语法。它实际上不是必需的，可以被一个可选组合子和一个重复组合子通过一个且组合子组合而成，但是由于它使用频繁，并且构建复杂，因此专门定义这样一种组合子方便使用。  
间隔重复组合子接受两个Parser，它首先使用第一个Parser进行分析，得到结果列表的初始值，然后将两个Parser用且组合子组合起来后贪婪地使用，然后将得到的结果对初始值列表进行归并。默认的归并操作丢弃输入的第二个Parser的分析结果，将第一个Parser的分析结果添加到结果列表末尾。例如，对于一个可以识别整数字面量的Parser和一个识别","的Parser，经过默认的间隔重复组合子组合后，可以将"1+2+3+4"分析为[1, 2, 3, 4]。

0. 语义动作组合子  
语义动作组合子接受一个Parser的输入，修改它的行为，使得其成功分析后执行特定的语义动作后再返回结果。它并不增强Parser的表达能力，只是为了将语义动作插入分析过程而定义的。

0. 惰性组合子  
惰性组合子严格地来说并非组合子，它接受一个返回Parser的函数，在需要时计算这个函数并用得到的Parser进行分析。这一组合子使得Parser可以表达递归的语法现象。具体见下文。

0. 结束组合子  
结束组合子也是一种修改输入Parser行为的组合子。它使得输入Parser在分析成功后进行判断，如果Tokens数组没有被全部分析完毕，则返回错误。这一组合子用于最后的封装以确保分析停止时Parser到达了EOF。

有了这些组合子之后就已经足以表达MiniJava的全部语法，大部分语法现象如何表达上文已经提及了，接下来详细说明两种语法现象的表示方法：递归和优先级。

**递归。**

对于右递归，我使用惰性组合子来表达。例如，对于`"!" Expression`的前缀运算符语法，用`ReservedParser("!") + Lazy(ExprParserGenerator)`（记为P）来表达。P本身是`ExprParser`的一部分（`ExprParser`由包括P的多个Parser通过或组合子组合起来），当使用`ExprParser`分析"!true"时，它尝试各种Parser，在尝试到P时，它首先调用`ReservedParser("!")`识别出"!"，然后调用`Lazy(ExprParserGenerator)`，后者会返回一个临时的`ExprParser`，该Parser能够识别出"true"，于是P的两侧均分析成功，`ExprParser`返回结果[!, true]。

通过这种方法，可以用一个不包含任何递归的Parser，通过惰性组合子的复合，逐步添加右递归语法。

对于左递归，我使用与课本上相同的消除左递归的方法，使用另一个惰性的临时的不含左递归的Parser，来取代左递归的Parser，将其变为右递归。实质上，或组合子产生的Parser进行尝试的过程，和课本方法构建FIRST集合，并在其中进行查找的方法是异曲同工的。

**优先级。**

优先级的实现是非常简单的，只需要将对算式表达式的Parser改为多级识别即可。具体来说，对于"1+2\*3"，可以简单地用一个不丢弃分隔符的间隔重复组合子，将其识别为[1, +, 2, \*, 3]，这一识别不支持优先级。但如果首先定义一个间隔重复组合子（记为P1），它的间隔符是高级运算符，例如乘号，它的重复内容是最基本的算术元素，例如整数；然后再定义一个间隔重复组合子（记为P2），它的间隔符是次高级运算符，例如加号，它的重复内容是P1；然后再用更低级的运算符，例如且运算符，和P2定义P3。如上，就得到了支持优先级的Parser：P3。在执行过程中，（容易理解地来讲，实际上并不是如此执行的）P3会将内容用P3的分隔符（且运算符）进行分隔，对于每一个分隔结果，使用P2进行分析，P2又会将P3的分隔结果用它的分隔符（加号）进行分隔，用P1分析分隔内容，P1会识别整数乘法或整数，P2将P1识别的整数乘法或整数分组形成P1结果的加法，P3将P2识别的结果分组形成P2结果的且运算。这样我就能对"0&&1+2\*3"得到[0, &&, [1, +, [2, \*, 3]]]了。

**错误处理与恢复。**

在语法分析阶段，我同样只进行了简单的错误报告。由于时间关系，没有实现错误恢复。由于在我的解决方案中，只有当前一个Token被暂时接收时，才会处理下一个Token，因此关注分析下标在一次分析中最远到达的位置，就可以知道错误发生的地点。每当原子Parser（最简单的两种Parser）匹配失败时，我就获得了在某个下标处分析器希望得到某种Token而失败的信息，当最终分析失败时，查看在最远下标处分析器希望得到的Token的信息，就知道了错误发生的地点及原因。

![](imgs/img2.png)

可以看到Parser报告了错误地点及原因，但没有恢复。

## 语义分析

对应的主要文件为`src/Semantic/*.swift`

由于时间关系，我只对一部分语法实现了语义，具体来说，是`factorial.java`文件中用到的语法实现了语义分析。我是通过递归地后序地分析AST树中每个结点的语义来实现这两点的。一般的，语义分析常常被结合在语义动作中执行，但我的实现中，为了更容易调试，而将这二者解耦，等到语法分析全部完成后再进行语义分析。

在声明检查中，我首先查看全部的类声明得到所有的合法类型，然后查看全部的类变量、局部变量及函数形参，检查是否有未定义的类型或是重名的变量。我允许了同名局部变量覆盖形参和类变量，同名形参覆盖类变量，通过在后面的类型检查中不贪心地搜索依次局部变量列表、形参列表和类变量列表来获取变量类型实现。

在类型检查中，我递归地后序地遍历AST树，对每个结点，根据其在语法分析时确定的结点类型（例如，是双目运算表达式，是函数调用语句等），确定检查方法，再以子结点返回的检查类型，确定该点上是否有类型错误，例如要求if语句的条件表达式必须为boolean类型，函数调用的参数类型必须与声明一致等。对于页结点，也就是字面量结点和变量结点（保留字结点在语义动作中被删去以成为AST树），前者，直接确定其类型并返回；后者，查找环境寻找其定义（可能会查找失败而报告变量未定义错误）。具体的实现是trivial的，不赘述。

**错误处理与恢复。**

语义分析阶段的错误处理如前所述。而该阶段事实上并不需要错误恢复，因为与前两个阶段不同，这一阶段发生的错误不会使得接下去的分析工作无法进行。

![](imgs/img3.png)

可以发现SemanticAnalyzer找出了全部的声明错误，包括重复声明和未知类型的声明和未声明的变量。

![](imgs/img4.png)

![](imgs/img5.png)

可以发现SemanticAnalyzer找出了全部的类型错误，包括返回类型错误，双目运算符操作数类型错误，赋值目标类型错误，方法调用的参数数量、类型错误。

## 模拟执行

对应的主要文件为`src/Emulation/*.swift`和`src/Semantic/ConcreteASTNode.swift`

为了检测我是否分析出了正确的AST树，我部分实现了简单的模拟执行功能。
**这并不是编译器的后端，甚至都不是解释器。**
只是类似语义分析，依赖于编译器宿主语言的运行时，递归地遍历AST树，模拟语句的效果而已。因为时间关系，同样只实现了一部分的（`factorial.java`文件中用到的）语法的模拟执行。

## 正确运行结果

![](imgs/img6.png)

使用正确的程序输入，可以发现成功分析并模拟执行，输出10的阶乘3628800。

输出的AST树，我使用折叠列表来进行可视化，如图：

![](imgs/img7.png)

![](imgs/img8.png)
