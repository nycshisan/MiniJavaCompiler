# 编译Project报告

###### 陈一川 14307110157@fudan.edu.cn

## 工具选择

没有使用第三方的词法\语法分析工具，这是因为我认为工业化的词法\语法分析工具（例如ANTLR）功能已经非常完善，凭我的能力无法再对其做改进。而我认为如果自己将工具链实现一遍，虽然效果相差许多，但能够学到更多的东西。其次，我去年时对编译原理比较感兴趣，曾经想自己实现一个编译器前端，但是半途而废了，这次趁此机会将它完成。（这也是git log中有去年的记录的原因）

我使用了正则表达式和组合子作为词法分析和语法分析的方式。具体见下。


## 词法分析

对应的主要文件为`src/Tokenizer/Tokenizer.swift`

我使用正则表达式作为从输入文本中不断获取Token的方式。原因有三，第一，正则表达式以足够表达MiniJava的简单词法，例如，MiniJava并没有C语言式的嵌套多行注释(`/* ... */`)这一正则表达式无法表达的词法规则；第二，贪婪的正则表达式自带最长匹配这一消除词法二义性的规则；第三，许多语言都自带一个正则表达式的执行器，Swift也不例外，使得使用正则表达式进行词法分析是简单易行的。

消除词法二义性的另一规则，规则优先，要求合适地设置正则表达式的匹配顺序。在本例中，我们设置正则表达式的匹配顺序为(1)空白符与注释(2)运算符与定界符(3)特别的保留字(4)标识符(5)整数字面量。

所谓特别的保留字，实际上指的就是`System.out.println`，在实际语言中，他应该被识别为一个对象属性表达式。我在MiniJava中为了简单起见，直接将其用于打印语句的关键字，为了能在语法分析阶段直接使用`System.out.println`而非[`System`, `.`, ...]进行分析，需要在词法分析阶段增加特殊的规则，事后发现反而使得Tokenizer更加复杂了。

识别为标识符的Token会被检查，如果是保留字，Token类别就会被修改为保留字以供语法分析阶段使用。

我将空白符和注释也视为Token（这类Token在匹配完成后会被舍弃，不会进入语法分析阶段），因此可以不断地从输入文本的头部得到正则表达式的最大贪婪匹配。使用一系列正则表达式依次对输入进行匹配，每当有一个正则表达式的匹配长度大于0，我们就截取这一子串，包装为Token，加入结果队列，并将这一子串从输入本文中删去，然后重复上述过程。当输入文本耗尽时，词法分析阶段完成，输入文本被分割为Tokens数组。

**错误处理与恢复。**

在词法处理阶段，我只是简单地处理了字符集的错误。当遇到MiniJava不允许含有的字符时（例如或运算符|），报告错误，删去这一字符并回退到上一次词法分析成功的地方继续进行分析，并在分析完成后退出。

## 语法分析

对应的主要文件为`src/Parser/*.swift`

我使用组合子（Combinators）作为语法分析的工具，简单地来说，就是首先定义最简单的几类Parser，然后定义几种将其复合起来的操作，通过这些操作，定义能够分析复杂的语法规则的Parser，最后得到一个能够分析整个语法系统的Parser。

我起初在查阅资料时发现了这样一种实现编译器前端的解决模式，因为它与课本所讲的编译原理并不相同，我觉得用一种与课本不同（虽然本质原理相同）的方式实现编译器前端是很有趣的。项目完成后，现在我认为，组合子编程模型并不适合作为编译系统的前端的解决方案，因为（在最坏条件下）它需要前向查看到输入末尾才能确定第一个Token的意思，虽然在成功编译的情况下，这种最坏条件几乎不会发生，但是在错误处理和恢复时，为了确定错误类型，这种最坏情况就常常出现。尽管如此，我仍然认为这种实现是很有趣的，因此还是将它作为我的课程项目。

最简单的Parser只有两种，一种识别单个Token的文本，一种识别单个Token的类型（保留字、运算符、整数字面量、标识符等等）。它们接受Tokens数组当前正在被分析的位置的下标作为参数，在该下标指向的位置上进行分析，如果满足条件，则将该Token包装为ASTNode返回，并将该下标加一。

复合操作则有许多种，它们被称为组合子，因为它们将较简单的Parser组合起来产生新的较复杂的Parser。下面依次介绍我使用的组合子：

0. 和组合子  
和组合子是使用最多的组合子，它接收两个Parser，输出一个新的Parser。这个Parser在执行分析时会依次调用输入的两个Parser，当二者均成功返回时，则将二者的返回结果组织成AST的子结点，并将父节点返回；否则返回失败。  
和组合子用于分析依次的输入。例如，对于两个Parser，分别能够分析"1"和"+"，那么用和组合子产生的复合Parser就能够分析"1+"。  
特别的，对于输入的Parser，如果它是由和组合子产生的，则新的Parser会将它的结果展平后再进行组织，这是为了方便语义动作的编写。例如，"1+1"会被分析为[1, +, 1]而非[[1, +], 1]。

0. 或组合子  
或组合字同样将两个Parser组合为一个Parser。这个Parser会返回二者中分析成功的Parser的分析结果，只有当二者均失败时才返回失败，其效果和输入的优先级就像或运算符一样。  
或组合字用于分析并列的输入。例如对于分别能够分析"1"和"2"的两个Parser，其产生的新Parser可以分析"1"或者"2"。

0. 可选组合子  
可选组合子只接受一个Parser的输入，它修改这个Parser的行为，使得其失败时不返回失败，而是返回一个空的AST结点。  
可选组合子用于分析可选的语法现象，例如类是否有写明继承，或者if语句是否有else块（虽然在MiniJava中强制所有if语句带有else块）。

0. 重复组合子  
重复组合子也只接受一个Parser的输入，它产生新的Parser，该Parser可以贪婪地不断重复输入Parser的行为，直到分析失败为止。它将得到的结果组织成AST的子结点，并将父节点返回。  
重复组合子用于分析不定次出现的语法现象。例如对于能够分析"1"的Parser，经过重复组合子组合之后，就能将"111"分析为[1, 1, 1]。实际中，它被用来分析语句块中的多个语句等现象。

0. 间隔重复组合子  
间隔重复组合子分析带有间隔的重复语法现象，例如函数参数中，每个参数之间有逗号的语法。它实际上不是必需的，可以被一个可选组合子和一个重复组合子通过一个且组合子组合而成，但是由于它使用频繁，并且构建复杂，因此专门定义这样一种组合子方便使用。  
间隔重复组合子接受两个Parser，它首先使用第一个Parser进行分析，得到结果列表的初始值，然后将两个Parser用且组合子组合起来后贪婪地使用，然后将得到的结果对初始值列表进行归并。默认的归并操作丢弃输入的第二个Parser的分析结果，将第一个Parser的分析结果添加到结果列表末尾。例如，对于一个可以识别整数字面量的Parser和一个识别","的Parser，经过默认的间隔重复组合子组合后，可以将"1+2+3+4"分析为[1, 2, 3, 4]。

0. 语义动作组合子  
语义动作组合子接受一个Parser的输入，修改它的行为，使得其成功分析后执行特定的语义动作后再返回结果。它并不增强Parser的表达能力，只是为了将语义动作插入分析过程而定义的。

0. 惰性组合子  
惰性组合子严格地来说并非组合子，它接受一个返回Parser的函数，在需要时计算这个函数并用得到的Parser进行分析。这一组合子使得Parser可以表达递归的语法现象。具体见下文。

0. 结束组合子  
结束组合子也是一种修改输入Parser行为的组合子。它使得输入Parser在分析成功后进行判断，如果Tokens数组没有被全部分析完毕，则返回错误。这一组合子用于最后的封装以确保分析停止时Parser到达了EOF。

有了这些组合子之后我们已经足以表达MiniJava的全部语法，大部分语法现象如何表达上文已经提及了，接下来详细说明两种语法现象的表示方法：递归和优先级。

**递归。**

对于右递归，我们使用惰性组合子来表达。例如，对于`"!" Expression`的前缀运算符语法，我们用`ReservedParser("!") + Lazy(ExprParserGenerator)`（记为P）来表达。P本身是`ExprParser`的一部分（`ExprParser`由包括P的多个Parser通过或组合子组合起来），当我们使用`ExprParser`分析"!true"时，它尝试各种Parser，在尝试到P时，它首先调用`ReservedParser("!")`识别出"!"，然后调用`Lazy(ExprParserGenerator)`，后者会返回一个临时的`ExprParser`，该Parser能够识别出"true"，于是P的两侧均分析成功，`ExprParser`返回结果[!, true]。

通过这种方法，可以用一个不包含任何递归的Parser，通过惰性组合子的复合，逐步添加右递归语法。

对于左递归，我使用与课本上相同的消除左递归的方法，使用另一个惰性的临时的不含左递归的Parser，来取代左递归的Parser，将其变为右递归。实质上，或组合子产生的Parser进行尝试的过程，和课本方法构建FIRST集合，并在其中进行查找的方法是异曲同工的。

**优先级。**

优先级的实现是非常简单的，只需要将对算式表达式的Parser改为多级识别即可。具体来说，对于"1+2\*3"，我们可以简单地用一个不丢弃分隔符的间隔重复组合子，将其识别为[1, +, 2, \*, 3]，这一识别不支持优先级。但如果我们首先定义一个间隔重复组合子（记为P1），它的间隔符是高级运算符，例如乘号，它的重复内容是最基本的算术元素，例如整数；然后再定义一个间隔重复组合子（记为P2），它的间隔符是次高级运算符，例如加号，它的重复内容是P1；然后再用更低级的运算符，例如且运算符，和P2定义P3。我们就得到了支持优先级的Parser：P3。在执行过程中，（容易理解地来讲，实际上并不是如此执行的）P3会将内容用P3的分隔符（且运算符）进行分隔，对于每一个分隔结果，使用P2进行分析，P2又会将P3的分隔结果用它的分隔符（加号）进行分隔，用P1分析分隔内容，P1会识别整数乘法或整数，P2将P1识别的整数乘法或整数分组形成P1结果的加法，P3将P2识别的结果分组形成P2结果的且运算。这样我们就能对"0&&1+2\*3"得到[0, &&, [1, +, [2, \*, 3]]]了。

**错误处理与恢复。**

## 语义分析

**错误处理与恢复。**
