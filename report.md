# 编译Project报告

###### 陈一川 14307110157@fudan.edu.cn

## 工具选择

没有使用第三方的词法\语法分析工具，这是因为我认为工业化的词法\语法分析工具（例如ANTLR）功能已经非常完善，凭我的能力无法再对其做改进。而我认为如果自己将工具链实现一遍，虽然效果相差许多，但能够学到更多的东西。其次，我去年时对编译原理比较感兴趣，曾经想自己实现一个编译器前端，但是半途而废了，这次趁此机会将它完成。（这也是git log中有去年的记录的原因）

我使用了正则表达式和组合子作为词法分析和语法分析的方式。具体见下。


## 词法分析

对应的主要文件为`src/Tokenizer/Tokenizer.swift`

我使用正则表达式作为从输入文本中不断获取Token的方式。原因有三，第一，正则表达式以足够表达MiniJava的简单词法，例如，MiniJava并没有C语言式的嵌套多行注释(`/* ... */`)这一正则表达式无法表达的词法规则；第二，贪婪的正则表达式自带最长匹配这一消除词法二义性的规则；第三，许多语言都自带一个正则表达式的执行器，Swift也不例外，使得使用正则表达式进行词法分析是简单易行的。

消除词法二义性的另一规则，规则优先，要求合适地设置正则表达式的匹配顺序。在本例中，我们设置正则表达式的匹配顺序为(1)空白符与注释(2)运算符与定界符(3)特别的保留字(4)标识符(5)整数字面量。

所谓特别的保留字，实际上指的就是`System.out.println`，在实际语言中，他应该被识别为一个对象属性表达式。MiniJava中为了简单起见，直接将其用于打印语句的关键字，反而复杂了Tokenizer的实现，因为它必须占用一条特殊的规则。

识别为标识符的Token会被检查，如果是保留字，Token类别就会被修改为保留字以供语法分析阶段使用。

我将空白符和注释也视为Token（这类Token在匹配完成后会被舍弃，不会进入语法分析阶段），因此可以不断地从输入文本的头部得到正则表达式的最大贪婪匹配。每当有一个正则表达式的匹配长度大于0，我们就截取这一子串，包装为Token，加入结果队列，并将这一子串从输入本文中删去。当输入文本耗尽时，词法分析阶段完成，输入文本被分割为Token序列。


## 语法分析

